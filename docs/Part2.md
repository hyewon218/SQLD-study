# 2. SQL 기본 및 활용

## SQL 기본


### WHERE 절
#### 📍 NULL 관련 함수
- NVL 함수(Oracle) : NULL 이면 다른 값으로 바꾸는 함수이다.
  - NVN(MGR, 0) 은 MGR 칼럼이 NULL 이면 0으로 바꾼다.
- NVL 함수(Oracle) : NVL 함수와 DECODE(if) 함수를 하나로 만든 것이다. 
  - NVL2(MGR, **1**, 0) 은 MGR 칼럼이 **NULL 이 아니면 1**을, NULL 이면 0을 반환한다.
- 📌 NULLIF 함수(Oracle, MS-SQL, MySQL) : 두 개의 값이 **같으면 NULL** 을, **같지 않으면 첫 번째 값**을 반환한다.
  - NULLIF(exp1, exp2) 은 exp1과 exp2가 같으면 NULL 을, 같지 않으면 exp1 을 반환한다.
- COALESCE(Oracle, MS-SQL, MySQL) : **NULL 이 아닌 최초의 인자 값**을 반환한다.
  - COALESCE(exp1, exp2, exp3) 은 **exp1이 NULL 이 아니면 exp1**의 값을, 그렇지 않으면 그 뒤의 값의 NULL 여부를 판단하여 값을 반환한다.

### 표준조인
#### 📍 NATURAL JOIN 은 두 테이블 간에 동일한 칼럼 이름을 가진 것을 모두 출력하는 (INNER)조인 방법이다.
- **Alias 를 사용할 수 없다.**
- 두 테이블에서 동일한 칼럼 이름을 가지는 칼럼은 **모두** 조인된다.
- 📌 동일한 칼럼이 두 개 이상일 경우 `JOIN ~ USING` 문장을 사용한다.
  - **USING 조건절** : FROM 절의 `USING 조건절`을 이용하면 같은 이름을 가진 칼럼들 중에서 원하는 칼럼에 대해서만 **선택적으로** INNER JOIN 을 할 수가 있다.
  - **ON 조건절** : JOIN 서술부(ON 조건절)와 비 JOIN 서술부(WHERE 조건절)를 분리하여 이해가 쉬우며 **칼럼명이 다르더라도** JOIN 조건을 사용할 수 있는 장점이 있다.
- 데이터 타입이 다르면 조인이 되지 않는다.

#### 📍 CROSS JOIN 은 테이블 간 JOIN 조건이 없는 경우 생길 수 있는 모든 데이터의 조합을 말한다.
- 조인 조건구 없이 2개의 테이블을 하나로 조인한다.
- 조인구가 없기 때문에 `카테시안 곱`이 발생한다.
- 예를 들어 행이 14개 있는 테이블과 행이 4개 있는 테이블을 조인하면 56개의 행이 조회된다.
- CROSS JOIN 은 **FROM 절**에 "CROSS JOIN" 구를 사용하면 된다.

<br>

## SQL 활용
### 서브쿼리
- 서브쿼리는 SELECT 문 내에 다시 SELECT 문을 사용하는 SQL 문이다.
  - `SELECT` 절에 위치한 서브쿼리 : **스칼라 서브쿼리**
    - **반드시 한행과 한 컬럼만 반환**
    - 여러 행이 반환되면 오류가 발생한다.
  - `FROM` 절에 위치한 서브쿼리 : **인라인뷰 서브쿼리**
    - 쿼리 안의 뷰의 형태로 테이블처럼 조회할 데이터를 정의하기 위해 사용
    - 테이블명이 존재하지 않기 때문에 다른 테이블과 조인 시 반드시 테이블 별칭 명시
       (단독으로 사용하는 경우 불필요)
    - 인라인뷰의 결과와 메인쿼리 테이블과 조인할 목적으로 주로 사용
    - 모든 연산자 사용 가능
    - `WHERE` 절 서브쿼리와 다르게 **서브쿼리 결과를 메인 쿼리의 어느 절에서도 사용할 수 있음**
    - 📌 인라인뷰 서브쿼리 내부에서는 메인 쿼리의 칼럼이나 값을 사용할 수 없다.
    - 📌 인라인뷰 서브쿼리는 **메인쿼리에서 인라인뷰 서브쿼리가 출력한 칼럼 혹은 값을 사용할 수 있다.**
  - `WHERE` 절에 위치한 서브쿼리 : 서브쿼리
    - 📌 서브쿼리는 메인쿼리의 칼럼을 모두 사용할 수 있지만, **메인쿼리는 서브쿼리의 칼럼을 사용할 수 없다**.
  - `HAVING` 절에 위치한 서브쿼리 : 서브쿼리

<br>

### 그룹함수
#### ROLLUP
<img src="https://github.com/hyewon218/kim-jpa2/assets/126750615/7eb77bb2-73c3-4298-b0b9-4e4e7c60d856" width="50%"/><br>
> 위 이미지가 ROLLUP의 원리를 전부 설명해 준다. 각 번호는 해당 칼럼으로 GROUP BY를 한 결과를 준다는 뜻이다. 첫번째 GROUP BY절 같은 경우는 총 4개의 GROUP을 만든다는 뜻이다. ROLLUP은 아래와 같은 원리로 실행된다.

1. ROLLUP의 인자로 들어온 칼럼을 오른쪽부터 하나씩 빼면서 GROUP을 만듭니다.
2. "()"의 의미는 GROUP이 없는 즉, 전체에 대한 결과를 출력한다는 뜻 입니다. EX(SUM 함수 사용하면 전체 SUM 구한다는 뜻)
3. 괄호로 묶여져 있는 컬럼은 하나로 본다는 뜻 입니다.
4. ROLLUP 이전에 일반 컬럼과 GROUP BY 한다면, 일반 컬럼은 끝까지 남습니다.

<br>

### 윈도우함수
#### 행 순서 관련 함수
- 행 순서 관련 함수는 상위 행의 값을 하위에 출력하거나 하위 행의 값을 상위 행에 출력할 수 있다.
- 특정 위치의 행을 출력할 수 있다. 
  #### 행 순서 관련 윈도우 함수
  - `FIRST_VALUES` : 파티션에서 가장 처음에 나오는 값을 구한다. <br>MIN 함수를 사용해서 같은 결과를 구할 수 있다.
  - `LAST_VALUES` : 파티션에서 가장 나중에 나오는 값을 구한다. <br> MAX 함수를 사용해서 같은 결과를 구할 수 있다.
  - `LAG` : **이전 행**을 가지고 온다.
  - `LEAD` : 윈도우에서 특정 위치의 행을 가지고 온다. <br> 기본값은 **1**이다.

<br>

### 계층형 조회(CONNECT BY)
- 계층형 조회는 Oracle 데이터베이스에서 지원하는 것으로 계층형으로 데이터를 조회할 수 있다.
- 예를 들어 부장에서 차장, 차장에서 과장, 과장에서 대리, 대리에서 사원 순으로 트리 형태의 구조를 위에서 아래로 탐색하면서 조회하는 것이다. 물론 역방향 조회도 가능하다.
- CONNECT BY 는 트리 형태의 구조로 질의를 수행하는 것으로 `START WITH` 구는 시작 조건을 의미하고 `CONNECT BY PRIOR` 는 조인 조건이다. Root 노드로부터 하위 노드의 질의를 실행한다.
- 계층형 조회에서 `MAX(LEVEL)` 을 사용하여 **최대 계층 수**를 구할 수 있다. 즉, 계층형 구조에서 마지막 Leaf Node 의 계층값을 구한다.
- 계층형 조회 결과를 명확히 보기 위해서 `LPAD` 함수를 사용할 수 있다.
  #### CONNECT BY 키워드
  - `LEVEL` : 검색 항목의 깊이를 의미한다, 즉, 계층구조에서 가장 상위 레벨(루트 노드)이 **1**이 된다.


- `Connect by` 구는 순방향 조회와 역방향 조회가 있다. **순방향 조회는 부모 엔터티로부터 자식 엔터티를 찾아가는 검색**을 의미하고, 역방향 조회는 자식 엔터티로부터 부모 엔터티를 찾아가는 검색이다.
  #### 📌 계층형 조회
  - `PRIOR 자식 = 부모` : 부모에서 자식 방향으로 검색을 수행하는 **순방향** 전개
  - `PRIOR 부모 = 자식` : 자식에서 부모 방향으로 검색을 수행하는 역방향 전개
  - `NOCYCLE` : 사이클이 발생하지 않게 한다.
  - `Order siblings by 컬럼명` : 동일한 LEVEL 인 **형제노드 사이에서 정렬을 수행**한다.

<br>

### PIVOT 과 UNPIVOT
PIVOT 이란 테이블에서 하나의 칼럼에 있는 행 값들을 펼쳐 각각을 하나의 컬럼으로만 만들어주는 것을 의미한다.
즉, 데이터를 **행기반에서 열기반**으로 바꾸는 것이 `PIVOT` 이고 다시 **열기반에서 행기반**으로 바꾸는 것이 `UNPIVOT` 이다.

<br>